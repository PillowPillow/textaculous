// textaculous
// version: 0.1.0
// author: 
// generated: Thu Apr 23 2015 16:36:11 GMT+0200 (Paris, Madrid (heure d’été))
// Autogenerated, do not edit. All changes will be undone.
(function (window,document,angular) {

	" use strict; ";
	angular.module('textaculous', []);
	angular.module('textaculous').constant('textaculous.constants.config', {
		tag: '@',
		classes: 'drop-theme-arrows-bounce',
		position: 'bottom left'
	});
	angular.module('textaculous').run(['$templateCache', function($templateCache) {
		$templateCache.put('../lib/templates/textaculous.jade',
			'<section class="front">\n' +
			'  <textarea ng-click="selectText($event)" ng-model="raw" ng-trim="false" wrap="hard"></textarea>\n' +
			'</section>\n' +
			'<section class="back">\n' +
			'  <pre class="highlight"><span ng-repeat="part in Textaculous.text track by $index"><span ng-if="!isHighlighted($index)">{{part}}</span><span ng-if="isHighlighted($index)" class="highlighted">{{part}}</span></span></pre>\n' +
			'</section>\n' +
			'<section class="hidden-container">\n' +
			'  <article class="tether-pop"></article>\n' +
			'</section>');
	}]);
	
	angular.module('textaculous').service('textaculous.drop', ['textaculous.parser', 'textaculous.constants.config', function (parserService, CONFIG) {
		var currentTether,
		    currentTarget,
		    closeEvents = [];
	
		this.trigger = trigger;
		this.pop = pop;
		this.close = close;
		this.onClose = onClose;
	
		this._init = _init;
	
		this._init();
	
		function trigger(_ref, content) {
			var highlightedRanges = _ref.highlightedRanges;
			var positionStart = _ref.positionStart;
			var positionEnd = _ref.positionEnd;
			var event = _ref.event;
			var node = _ref.node;
	
			positionEnd = positionEnd || positionStart;
	
			var index = parserService.isInRange(highlightedRanges, { start: positionStart, end: positionEnd });
			if (!! ~index) {
				this.pop({ index: index, node: node }, content);
				event && event.stopPropagation();
			} else this.close();
	
			return index;
		}
	
		function pop(_ref2, content) {
			var index = _ref2.index;
			var node = _ref2.node;
	
			var newTarget = index === undefined ? node : node.querySelectorAll('.highlighted')[index];
			if (!newTarget || newTarget === currentTarget) {
				return;
			}if (currentTether) currentTether.destroy();
	
			currentTether = new Drop({
				target: newTarget,
				content: content,
				classes: CONFIG.classes,
				position: CONFIG.position,
				constrainToWindow: false,
				constrainToScrollParent: false,
				openOn: ''
			});
	
			currentTarget = newTarget;
			currentTether.content.addEventListener('click', function (event) {
				return event.stopPropagation();
			});
			currentTether.setupTether();
			currentTether.open();
		}
	
		function close() {
			if (currentTether) {
				currentTarget = null;
				currentTether.close();
				execOnClosEvents();
			}
		}
	
		function execOnClosEvents() {
			for (var i = 0; i < closeEvents.length; i++) closeEvents[i].call();
		}
	
		function onClose(callback) {
			closeEvents.push(callback);
		}
	
		function _init() {
			var _this = this;
	
			var html = document.querySelector('html');
			html.addEventListener('click', function () {
				return _this.close();
			});
		}
	}]);
	angular.module('textaculous').service('textaculous.parser', ['textaculous.constants.config', function (CONFIG) {
	
		var regex = generateRegex(CONFIG.tag);
	
		this.parse = parse;
		this.isInRange = isInRange;
	
		function isInRange(ranges, _ref) {
			var start = _ref.start;
			var end = _ref.end;
	
			var searchIndex = -1;
			for (var index = 0; index < ranges.length; index++) if (ranges[index][0] <= start && end <= ranges[index][1]) {
				searchIndex = index;
				break;
			}
	
			return searchIndex;
		}
	
		function parse(value) {
	
			var splitted = splitRaw(value),
			    $length = 0,
			    highlightedRanges = [],
			    highlightedIndexes = [],
			    highlighted = [];
	
			for (var i = 0; i < splitted.length; i++) {
				if (splitted[i][0] === CONFIG.tag && splitted[i].length > 1) {
					highlighted.push(splitted[i]);
					highlightedIndexes.push(i);
					highlightedRanges.push([$length, $length + splitted[i].length]);
				}
				$length += splitted[i].length;
			}
	
			return { splitted: splitted, highlightedRanges: highlightedRanges, highlighted: highlighted, highlightedIndexes: highlightedIndexes };
		}
	
		function splitRaw(string) {
			return string.split(regex);
		}
	
		function generateRegex(tag) {
			return new RegExp('(\\' + tag + '[^\\s]+)');
		}
	}]);
	angular.module('textaculous').controller('textaculous.controllers.textaculous', function () {
	
		this.$$ranges = [];
		this.$$highlighted = [];
		this.$$highlightedIndexes = [];
		this.$$textarea = undefined;
		this.$$tetherContent = undefined;
		this.$$currentIndex = -1;
	});
	var _slicedToArray = function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } };
	
	angular.module('textaculous').directive('textaculous', ['textaculous.parser', 'textaculous.drop', '$interval', function (parserService, dropService, $interval) {
		return {
			scope: {
				raw: '=ngModel'
			},
			restrict: 'AE',
			templateUrl: '../lib/templates/textaculous.jade',
			controller: 'textaculous.controllers.textaculous',
			controllerAs: 'Textaculous',
			require: ['textaculous', 'ngModel'],
			transclude: true,
			compile: function compile() {
				return function ($scope, $node, attributes, _ref, transclude) {
					var _ref2 = _slicedToArray(_ref, 2);
	
					var textaculous = _ref2[0];
					var ngModel = _ref2[1];
	
					var node = $node[0],
					    carretPosition = { start: undefined, end: undefined };
	
					textaculous.text = [];
					textaculous.$$ranges = [];
					textaculous.$$highlighted = [];
					textaculous.$$textarea = node.querySelector('textarea');
					textaculous.$$tetherContent = node.querySelector('.tether-pop');
					textaculous.$$currentIndex = -1;
	
					Object.defineProperties(textaculous, {
						range: {
							get: function get() {
								return !! ~textaculous.$$currentIndex ? textaculous.$$ranges[textaculous.$$currentIndex] : undefined;
							} },
						current: {
							get: function get() {
								return !! ~textaculous.$$currentIndex ? textaculous.$$highlighted[textaculous.$$currentIndex].slice(1) : '';
							},
							set: function set(value) {
								return !! ~textaculous.$$currentIndex && replaceHighlighted(value);
							}
						}
					});
	
					angular.element(textaculous.$$textarea).on('keydown keyup', clearCarretPosition);
	
					dropService.onClose(clearCarretPosition);
	
					$scope.selectText = function (event) {
						clearCarretPosition();
	
						textaculous.$$currentIndex = dropService.trigger({
							highlightedRanges: textaculous.$$ranges,
							positionStart: textaculous.$$textarea.selectionStart,
							positionEnd: textaculous.$$textarea.selectionEnd,
							event: event,
							node: node
						}, textaculous.$$tetherContent);
	
						if (!! ~textaculous.$$currentIndex) {
							carretPosition.start = textaculous.$$textarea.selectionStart;
							carretPosition.end = textaculous.$$textarea.selectionEnd;
						}
	
						return textaculous.$$currentIndex;
					};
	
					$scope.isHighlighted = function (index) {
						return !! ~textaculous.$$highlightedIndexes.indexOf(index);
					};
	
					$scope.$watch('raw', function (value) {
						var _parserService$parse = parserService.parse(value);
	
						var highlightedRanges = _parserService$parse.highlightedRanges;
						var splitted = _parserService$parse.splitted;
						var highlighted = _parserService$parse.highlighted;
						var highlightedIndexes = _parserService$parse.highlightedIndexes;
	
						textaculous.text = splitted;
						textaculous.$$ranges = highlightedRanges;
						textaculous.$$highlighted = highlighted;
						textaculous.$$highlightedIndexes = highlightedIndexes;
	
						if (carretPosition.start !== undefined && carretPosition.end !== undefined) {
							textaculous.$$textarea.selectionStart = carretPosition.start;
							textaculous.$$textarea.selectionEnd = carretPosition.end;
						}
	
						var index = parserService.isInRange(textaculous.$$ranges, {
							start: textaculous.$$textarea.selectionStart,
							end: textaculous.$$textarea.selectionEnd
						});
	
						if (! ~index) {
							dropService.close();
							textaculous.$$currentIndex = -1;
						} else textaculous.$$currentIndex = index;
					});
	
					function clearCarretPosition() {
						carretPosition.start = undefined;
						carretPosition.end = undefined;
					}
	
					transclude($scope, function (clone) {
						return angular.element(textaculous.$$tetherContent).append(clone);
					});
	
					function replaceHighlighted(value) {
						return $scope.raw = '' + $scope.raw.slice(0, textaculous.$$ranges[textaculous.$$currentIndex][0] + 1) + '' + value + '' + $scope.raw.slice(textaculous.$$ranges[textaculous.$$currentIndex][1]);
					}
				};
			}
		};
	}]);
	angular.module('textaculous').directive('highlighted', ['textaculous.drop', function (dropService) {
		return {
			restrict: 'C',
			scope: {},
			require: '^textaculous',
			link: function link($scope, $node, attributes, textaculous) {
				dropService.pop({ node: $node[0] }, textaculous.$$tetherContent);
			}
		};
	}]);

})(window,window.document,window.angular);